## Task #1 - modifyURL
Реализуйте и экспортируйте по умолчанию функцию, которая обновляет query string в переданном адресе в соответствии с указанными значениями.

Функция принимает на вход два параметра:
* адрес, который может содержать query string
* объект с параметрами, которые нужно проставить в query string
```
const address = 'https://amazon.com/search?page=10&per=5';
const params = { page: 100, per: null, order: 'desc', hidden: false };
modifyURL(address, params); // 'https://amazon.com/search?page=100&order=desc&hidden=false'
```
Правила подстановки следующие:
* Если параметра не было, то он добавляется
* Если параметр уже был, то его значение заменяется тем, которое передано в объекте
* Если значение параметра null, то сам параметр должен отсутствовать в адресе, даже если он там был.

## Task #2 - parseWIKI

В сети существует такая игра: вы получаете исходную ссылку на wiki страницу и необходимо за минимальное количество переходов дойти до статьи на заданную тему. Переходы осуществляются по любым ссылкам на странице, которые не выводят поиски за рамки википедии.

Реализуйте и экспортируйте по умолчанию функцию для поиска статьи на заданную тему по алгоритму описанному выше, кроме требования "за минимальное количество переходов". Проверку на внешние ссылки делать не надо. Наша цель асинхронность, а не сложность алгоритма.

Принимаемые параметры:
* title - название темы. Поиск должен происходить по точному соответствию.
* address - ссылка на страницу с которой будет производится поиск.
* callback - функция обратного вызова, в которую передается адрес найденной страницы либо ошибка. Ошибка возникает, например, в случае если были просмотрены все ссылки, а статья не найдена.

Важно учитывать:
* В статьях могут быть взаимные ссылки, поэтому необходимо отслеживать то что уже было посещено, чтобы не возникало бесконечной рекурсии.
Пример:
```
import solution from './solution';
 
solution('операция', 'http://localhost:8080', (err, data) => {
  console.log(data); // http://localhost:8080/operator
});
```
Все страницы имеют такую структуру:
```
<html>
  <head>
    <title></title>
  </head>
  <body>
    <h1>Википедия</h1>
    <p>Как вы знаете, вики это большая база знаний обо всем на свете.
      Наш сайт это не настоящая <a href="https://www.wikipedia.org/">википедия</a>,
      но кое что мы сюда добавили).</p>
    <p>Например статью про <a href="/operators">операции</a>, а так же статьи про
      <a href="/expressions">выражения</a> и <a href="/statements">инструкции</a></p>
  </body>
</html>
```
* Заголовок h1 содержит точное название темы
* Под заголовком абзац(ы) с произвольным текстом внутри которого встречаются ссылки по которым и нужно ходить

### Подсказки
* Для извлечения данных из текста воспользуйтесь функциями getTitle() и getLinks()

## Task #3 - CSRF
Реализуйте и экспортируйте по умолчанию функцию, которая с помощью http запросов, эмулируя поведение пользователя, выполняет регистрацию на сайте.

Функция принимает на вход четыре параметра:
* Адрес формы регистрации (get запрос)
* Адрес по которому необходимо отправить данные формы (post запрос)
* nickname - значение поля nickname из формы регистрации
* Коллбек, который будет вызван после окончания операции. Коллбек принимает на вход единственный параметр - err в случае если произошла ошибка.
```
import request from '../solution';
 
const registrationFormUrl = 'http://localhost:8080';
const submitFormUrl = 'http://localhost:8080/users';
const nickname = 'legolas';
request(registrationFormUrl, submitFormUrl, nickname, (err) => {
  // ...
});
```
На сайте реализована защита от csrf, поэтому перед непосредственной отправкой данных формы на соответствующий адрес, необходимо сделать запрос на форму регистрации, извлечь из нее токен и отправить его вместе с данными формы по нужному адресу.

В упражнении доступен веб-доступ, по которому открывается этот сайт. Попробуйте посмотреть исходный код страницы, найти там этот токен, а так же выполните регистрацию.

### Обработка ошибок

В случае если первый запрос вернет статус не 200, то вызываем коллбек и передаем туда ошибку. В случае если второй запрос вернет статус не 302, то так же вызываем коллбек и передаем ошибку.

### Подсказки
* Для извлечения токена из тела запроса, воспользуйтесь функцией getToken()
