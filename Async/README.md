# Async

## Task #1 - printFile
Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая читает данные файла по указанному пути и выводит их в консоль.

Примеры:
```
import print from './printer.js';
print('./myfile');
```

## Task #2 - writeFile

Реализуйте асинхронную функцию, которая записывает данные по указанному пути и оповещает о завершении работы через переданный колбек. Экспортируйте функцию по умолчанию.
```
import write from './writer.js';
 
write('./myfile', 'data', () => {
  console.log('success');
});
```
Подсказки:
* для записи в файл используйте функцию fs.writeFile().

## Task #4 - compareFileSizes

Реализуйте и экспортируйте асинхронную функцию compareFileSizes(), которая сравнивает размеры двух файлов и передает результат сравнения в переданную callback-функцию. Если первый файл больше второго, то она передает единицу, если размеры равны, то ноль, иначе — -1.

```
import { compareFileSizes } from './info.js';
 
compareFileSizes('filepath1', 'filepath2', (_err, result) => console.log(result));
```

Подсказка
* Для реализации этого задания, нужно воспользоваться функцией fs.stat, которая использовалась в примерах теории
* Math.sign

## Task #4 - moveFile
Реализуйте и экспортируйте функцию move, которая асинхронно перемещает файл из одного места в другое. Ее параметры:
* Путь до файла исходника
* Путь по которому нужно копировать файл
* Колбек, у которого единственный аргумент — ошибка.

Алгоритм работы функции следующий:
1) Читаем исходный файл
2) Создаём новый файл и записываем туда данные исходного файла (это важно сделать до попытки удаления исходного файла!)
3) Удаляем исходный файл
4) Реальная функция move устроена не так. Если исходник и приемник находятся на одном устройстве, то копирования не происходит, меняются лишь указатели в фс

```
import { move } from './file.js';
 
move('/opt/myfile', '/tmp/newfile', (error) => {
  if (error) {
    console.log('oops');
    return;
  }
  console.log('yes!');
});
```
Другие примеры смотрите в тестах

Подсказки
* fs.unlink - удаление файла
* fs.readFile - чтение файла
* fs.writeFile - запись в файл

## Task #5 - getDirectorySize
Реализуйте и экспортируйте асинхронную функцию getDirectorySize(), которая считает размер переданной директории не включая поддиректории. Анализ размера файла должен происходить параллельно, для этого воспользуйтесь библиотекой async

Примеры
```
import { getDirectorySize } from './info.js';
 
getDirectorySize('/usr/local/bin', (err, size) => {
  console.log(size);
});
```

Подсказки
* fs.readdir() - чтение содержимого директории, возвращает файлы и папки в директории
* path.join() - конструирует пути
* async.map()
* fs.stat() - информация о файле. В получаемом объекте содержится метод isFile() для проверки является ли элемент файлом
* _.sumBy() - нахождение суммы в массиве
* колбек должен вызываться и в случае ошибки

## Task #6 - watchFile

Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая следит за изменением файла с заданной периодичностью. Функция должна возвращать идентификатор таймера, запущенного внутри.

Если файл был изменён со времени предыдущей проверки, то необходимо вызвать колбек. Если во время анализа файла (через fs.stat) произошла ошибка, то нужно остановить таймер и вызвать колбек, передав туда ошибку.

Отслеживание изменений файла должно начинаться с момента вызова функции. Параметры функции:
* Путь до файла, который нужно отслеживать
* Период отслеживания
* Колбек, принимающий аргументом ошибку
```
import watch from './watcher.js';
 
const id = watch(filepath, 500, (err) => {
  console.log('Wow!');
});
 
setTimeout(() => fs.appendFileSync(filepath, 'ehu'), 700);
setTimeout(() => clearInterval(id), 5000); // остановить отслеживание через 5 секунд
```
Ваша функция должна возвращать id таймера.

### Подсказки
* stats.mtimeMs — время последнего изменения
* Date.now() — текущая дата
* clearInterval
