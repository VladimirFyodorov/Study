# Async

## Task #1 - printFile
Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая читает данные файла по указанному пути и выводит их в консоль.

Примеры:
```
import print from './printer.js';
print('./myfile');
```

## Task #2 - writeFile

Реализуйте асинхронную функцию, которая записывает данные по указанному пути и оповещает о завершении работы через переданный колбек. Экспортируйте функцию по умолчанию.
```
import write from './writer.js';
 
write('./myfile', 'data', () => {
  console.log('success');
});
```
Подсказки:
* для записи в файл используйте функцию fs.writeFile().

## Task #4 - compareFileSizes

Реализуйте и экспортируйте асинхронную функцию compareFileSizes(), которая сравнивает размеры двух файлов и передает результат сравнения в переданную callback-функцию. Если первый файл больше второго, то она передает единицу, если размеры равны, то ноль, иначе — -1.

```
import { compareFileSizes } from './info.js';
 
compareFileSizes('filepath1', 'filepath2', (_err, result) => console.log(result));
```

Подсказка
* Для реализации этого задания, нужно воспользоваться функцией fs.stat, которая использовалась в примерах теории
* Math.sign

## Task #4 - moveFile
Реализуйте и экспортируйте функцию move, которая асинхронно перемещает файл из одного места в другое. Ее параметры:
* Путь до файла исходника
* Путь по которому нужно копировать файл
* Колбек, у которого единственный аргумент — ошибка.

Алгоритм работы функции следующий:
1) Читаем исходный файл
2) Создаём новый файл и записываем туда данные исходного файла (это важно сделать до попытки удаления исходного файла!)
3) Удаляем исходный файл
4) Реальная функция move устроена не так. Если исходник и приемник находятся на одном устройстве, то копирования не происходит, меняются лишь указатели в фс

```
import { move } from './file.js';
 
move('/opt/myfile', '/tmp/newfile', (error) => {
  if (error) {
    console.log('oops');
    return;
  }
  console.log('yes!');
});
```
Другие примеры смотрите в тестах

Подсказки
* fs.unlink - удаление файла
* fs.readFile - чтение файла
* fs.writeFile - запись в файл

## Task #5 - getDirectorySize
Реализуйте и экспортируйте асинхронную функцию getDirectorySize(), которая считает размер переданной директории не включая поддиректории. Анализ размера файла должен происходить параллельно, для этого воспользуйтесь библиотекой async

Примеры
```
import { getDirectorySize } from './info.js';
 
getDirectorySize('/usr/local/bin', (err, size) => {
  console.log(size);
});
```

Подсказки
* fs.readdir() - чтение содержимого директории, возвращает файлы и папки в директории
* path.join() - конструирует пути
* async.map()
* fs.stat() - информация о файле. В получаемом объекте содержится метод isFile() для проверки является ли элемент файлом
* _.sumBy() - нахождение суммы в массиве
* колбек должен вызываться и в случае ошибки

## Task #6 - watchFile

Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая следит за изменением файла с заданной периодичностью. Функция должна возвращать идентификатор таймера, запущенного внутри.

Если файл был изменён со времени предыдущей проверки, то необходимо вызвать колбек. Если во время анализа файла (через fs.stat) произошла ошибка, то нужно остановить таймер и вызвать колбек, передав туда ошибку.

Отслеживание изменений файла должно начинаться с момента вызова функции. Параметры функции:
* Путь до файла, который нужно отслеживать
* Период отслеживания
* Колбек, принимающий аргументом ошибку
```
import watch from './watcher.js';
 
const id = watch(filepath, 500, (err) => {
  console.log('Wow!');
});
 
setTimeout(() => fs.appendFileSync(filepath, 'ehu'), 700);
setTimeout(() => clearInterval(id), 5000); // остановить отслеживание через 5 секунд
```
Ваша функция должна возвращать id таймера.

### Подсказки
* stats.mtimeMs — время последнего изменения
* Date.now() — текущая дата
* clearInterval

## Task #7 - reverseFile

Реализуйте и экспортируйте асинхронную функцию reverse(), которая изменяет порядок расположения строк в файле на обратный. Функция должна перезаписать файл.

```
# file.txt
one
two
```

```
import { reverse } from './file.js';
 
reverse('file.txt');
// two
// one
```

## Task #8 - touch
Реализуйте и экспортируйте асинхронную функцию touch(), которая создаёт файл, если его не существует. Если файл существует, то функция должна успешно завершиться.
```
import { touch } from './file.js';
 
touch('/myfile').then(() => console.log('created!'));
 
// Повторный вызов успешно завершается
touch('/myfile').then(() => console.log('created!'));
```
### Подсказка
* fsPromises.access — проверка существования файла

## Task #9 - getTypes

Реализуйте и экспортируйте асинхронную функцию getTypes(), которая анализирует список переданных путей и возвращает массив (в промисе), с описанием того, что находится по каждому из путей в виде строк 'directory' и 'file'.

Эта функция должна отрабатывать успешно в любом случае. Если во время выполнения асинхронной операции возникла ошибка, то значением для этого пути будет null. Для простоты считаем, что в эту функцию всегда передается как минимум один путь для обработки (иначе придется задействовать механизм, который проходится в курсах далее).

Примеры
```
import { getTypes } from './file.js';
 
getTypes(['/etc', '/etc/hosts', '/undefined']).then(console.log);
// ['directory', 'file', null]
```

### Подсказки
* fsPromises.stat - информация о файле или директории. Для проверки на директорию используйте метод isDirectory.
* Методы then и catch не меняют сам промис, а возвращают новый

## Task #10 - getDirectorySize

Реализуйте и экспортируйте асинхронную функцию getDirectorySize(), которая считает размер переданной директории (не включая поддиректории).

Пример:
```
import { getDirectorySize } from './file.js';
 
getDirectorySize('/usr/local/bin').then(console.log);
```
### Подсказка
* fsPromises.readdir - чтение содержимого директории
* path.join - конструирует пути
* fsPromises.stat - информация о файле
* _.sumBy - нахождение суммы в массиве

## Task #11 - timer
Реализуйте таймер в виде промиса. Функция должна принимать на вход количество миллисекунд и возвращать промис.
```
import wait from './timer.js';
 
wait(100).then(() => console.log('time is over!'));
```
Экспортируйте функцию по умолчанию.

## Task #12 - exchange
Реализуйте и экспортируйте асинхронную функцию exchange(), которая обменивает содержимое двух файлов.
```
import { exchange } from './file.js';
 
exchange('/myfile1', '/myfile2');
```

## Task #13 - getBadLinks

Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход ссылку на страницу какого-то сайта, загружает содержимое этой страницы, извлекает из него ссылки и проверяет их доступность. Функция должна вернуть список битых ссылок.

```
import getBadLinks from '../checker.js';
 
const url = 'https://privet.hexlet';
const links = await getBadLinks(url);
console.log(links);
// Гипотетический пример:
// [
//   'https://privet.hexlet/somepage',
//   'https://privet.hexlet/another/page',
// ]
```
Проверка доступности:
Любые ссылки возвращающие коды ответа кроме 2xx (любые двухсотые) считаются битыми. Axios по умолчанию считает ошибочными все коды кроме 2xx и отправляет их в блок catch(). То есть если запрос axios.get() отработал без ошибок, то страница отдает 2xx код ответа, если завершился с ошибкой, то ответа либо нет, либо это не 2xx код. Такие ссылки считаются битыми.

### Подсказки
* Для извлечения ссылок со страницы воспользуйтесь функцией extractLinks(content)

## Task #14 - promisify

Реализуйте и экспортируйте по умолчанию функцию, которая "промисифицирует" асинхронные функции с колбеками.
```
import promisify from '../promisify.js';
 
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
 
const filepath = '/tmp/myfile';
 
writeFile(filepath, 'content')
  .then(() => readFile(filepath))
  .then(console.log);
```
Реализация этой функции опирается на тот факт, что колбек в асинхронных функциях всегда передается последним параметром.

### Подсказка
* Вам понадобятся rest и spread операторы

## Task #15 - ls
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход путь (абсолютный или относительный) и возвращает информацию о файлах и директориях, расположенных по этому пути. Данные возвращаются в виде массива объектов, где каждый элемент — это информация о конкретном файле: его путь и описание доступов (stat.mode). Объекты в массиве должны быть отсортированы по имени файла.

Примеры
```
import ls from '../ls.js';
 
await ls('/var');
// [
//   { filepath: '/var/local', mode: 17917 },
//   { filepath: '/var/lock', mode: 17407 },
//   { filepath: '/var/log', mode: 16877 },
// ];
 
await ls('/etc/passwd');
// [{ filepath: '/etc/passwd', mode: 33188 }];
 
await ls('../../../../etc/passwd');
// [{ filepath: '/etc/passwd', mode: 33188 }];
```
Эта функция должна уметь обрабатывать не только директории, но и файлы. В таком случае отдается массив с одним объектом — информацией по текущему файлу.

### Подсказки
* readdir() — чтение директории
* stat() — информация о файле. isFile() — является ли файлом, mode - описание доступа.
* zipWith() — вспомогательная функция из lodash.

## Task #16 - makeTimer

Реализуйте и экспортируйте по умолчанию функцию, которая возвращает объект-таймер. Таймер "заводится" на определенное время и запускается. Каждые 100 миллисекунд он вызывает колбек, передавая туда два параметра: state со значением working и elapsedTime содержащий прошедшее время со старта таймера (в миллисекундах). Когда таймер завершился, то он вызывает тот же колбек с параметром state и значением finished.

```
// Колбек
const cb = ({ state, elapsedTime }) => {
  switch (state) {
    case 'working':
      console.log(`Time elapsed: ${elapsedTime}`);
      break;
    case 'finished':
      console.log(`Timer has finished!`);
  }
};
 
// Создается объект-таймер
const timer = makeTimer(300, cb); // Завели на 300 миллисекунд
timer.start();
// Time elapsed: 100
// Time elapsed: 200
// Time elapsed: 300
// Timer has finished!
```

### Подсказки
* Таймеры
* Для запуска таймера используйте setInterval
* Для остановки clearInterval
* Каждый новый тик не должен никак влиять на другие тики. Данные должны быть изолированы

## Task #17 - CustomPromise: then

Серия испытаний CustomPromise затрагивает множество тем, тесно связана со стандартом ecma и будет полезна для прокачки опытным разработчикам. Если тема классов и позднего связывания вам пока плохо знакомы, то продолжайте обучение и возвращайтесь к этим испытаниям позже.

В данном испытании вы собственными силами начнёте реализовывать "облегчённую" версию объекта Promise. Последующие испытания будут раскрывать тему и дополнять её новой функциональностью.

В данном испытании необходимо создать только класс, без асинхронности, но с цепочкой вызовов. Для этого реализуйте в классе CustomPromise конструктор, принимающий колбек executor(resolve) и метод then(callback);

В решении должны отсутствовать встроенные Promise и ключевое слово async.

Примеры использования
```
import CustomPromise from '../CustomPromise.js';
 
const promise = new CustomPromise((resolve) => resolve('Hello, world!'));
promise
  .then((value) => {
    console.log(value); // 'Hello, world!'
  });
 
const result = await promise
  .then((value) => value.replace('Hello', 'Goodbye'))
  .then((value) => value.toUpperCase());
console.log(result); // GOODBYE, WORLD!
```
### Подсказки
Вам понадобится вспомогательный метод, чтобы замыкать значения.

Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

В решении учителя используется связывание через bind(), но в процессе решения можно упростить себе задачу, используя стрелочные функции.

## Task #18 - CustomPromise: States

Это испытание является продолжением предыдущего и теперь вы познакомитесь с автоматным программированием.

Реализуете в классе CustomPromise метод then(callback) и вызов обработчиков на основе состояния объекта. Состояния запишите в объект STATES и используйте его вместо текстовых значений.

Алгоритм
Для решения данной задачи вам уже понадобится "подглядывать" в стандарт, чтобы разобраться с неймингом и общим алгоритмом. В нём указаны состояния, между которыми совершаются переходы, начальное состояние объекта и "реакции" (функции) на изменение состояния.

Достаточно будет одного состояния - его установки и очистки, чтобы не усложнять реализацию. На изменение состояния должна происходить реакция, а если объект находится в начальном состоянии, то реакции должны накапливаться.

Для упрощения можно копировать решение учителя из предыдущего испытания и расширять его. В решении должны отсутствовать встроенные Promise и ключевое слово async. Только вызовы функций из функций.

Примеры использования
```
import CustomPromise from '../CustomPromise.js';
 
const promise = new CustomPromise((resolve) => resolve('Hello, world!'));
promise
  .then((value) => {
    console.log(value); // 'Hello, world!'
  });
 
const result = await promise
  .then((value) => value.replace('Hello', 'Goodbye'))
  .then((value) => value.toUpperCase());
console.log(result); // GOODBYE, WORLD!
```
### Подсказки
Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

Если почувствуете, что нужны дополнительные материалы:
* описание стандарта, который имплементируется в упражнении
* курс "Синхронная асинхронность", чуть глубже погружающий в тему
* курс "Автоматное программирование" о конечных автоматах, чем является промис

## Task #19 - CustomPromise: Event loop

Это испытание является продолжением предыдущего, расширяя количество состояний и добавляя асинхронную составляющую.

Ранее вы реализовали реакцию на некое состояние, теперь пришла пора добавить это состояние в объект и сделать реакцию на него асинхронной. Реализуйте в классе CustomPromise метод then(onFulfill) и обеспечьте асинхронное выполнение функции resolve(data).

Алгоритм
Используйте названия состояний из стандарта, так как они проверяются в тестах.

Можно копировать решение учителя из предыдущего испытания и расширять его. В решении должны отсутствовать встроенные Promise и ключевое слово async. Только таймеры и вызовы функций из функций.

Примеры использования
```
import CustomPromise from '../CustomPromise.js';

const messages = [];

const resolvedPromise = new CustomPromise((resolve) => {
  resolve('Сначала резолвим?');
});

const modifiedPromise = resolvedPromise
  .then(() => { messages.push('Сначала меняем статус.'); });

await modifiedPromise
  .then(() => { messages.push('А уже потом резолвим.') });

console.log(messages.join(' ')); // Сначала меняем статус. А уже потом резолвим.
```
### Подсказки
Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

Если почувствуете, что нужны дополнительные материалы:
* курс "Синхронная асинхронность", чуть глубже погружающий в тему
* курс "Автоматное программирование" о конечных автоматах, чем является промис


## Task #20 - CustomPromise: reject

Это испытание является продолжением предыдущего и расширяет функционал функции executor, добавлением колбека reject(data).

Реализуйте в классе CustomPromise конструктор, принимающий колбек executor(resolve, reject) и метод then(onFulfill, onReject). Задачи resolve(data) и reject(error) должны выполняться асинхронно.

Алгоритм
Вам понадобится последнее, третье состояние, чтобы запускать реакции, накопленные по соответствующему состоянию промиса, сам объект с состояниями теперь можно реализовать внутри конструктора.

Можно копировать решение учителя из предыдущего испытания и расширять его. В решении должны отсутствовать встроенные Promise и ключевое слово async. Только таймеры и вызовы функций из функций.

Метод catch сейчас реализовывать не нужно, пусть всё попадает в then.

Примеры использования
```
import CustomPromise from '../CustomPromise.js';

const promise = new CustomPromise((resolve, reject) => reject('Hello, world!'));
promise
  .then((value) => {
    console.log(value); // Данный обработчик будет пропущен
  });


const result = await promise.then((x) => x.toUpperCase());
console.log(result); // 'Hello, world!'
```
### Подсказки
Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

Если почувствуете, что нужны дополнительные материалы:
* описание стандарта, который имплементируется в упражнении
* курс "Синхронная асинхронность", чуть глубже погружающий в тему
* курс "Автоматное программирование" о конечных автоматах, чем является промис

## Task #21 - Promise: catch
CustomPromise.js

Это испытание является продолжением предыдущего и расширяет объект промиса добавлением метода catch(onReject). Вы научитесь перехватывать и обрабатывать ошибки.

Реализуйте в классе CustomPromise конструктор, принимающий колбек executor(resolve, reject), методы then(onFulfill, onReject) и catch(onReject), и обеспечьте корректный перехват ошибок с передачей в соответствующие обработчики.

Алгоритм
Обработчик reject(data) экзекьютора вызывается только при выбросе ошибки. Решение, в целом, похоже на всё то что уже рассматривалось ранее, но реализация метода catch(onReject) отличается от then(onFulfill).

Можно копировать решение учителя из предыдущего испытания и расширять его. В решении должны отсутствовать встроенные Promise и ключевое слово async. Только таймеры и вызовы функций из функций.

Примеры использования
```
import CustomPromise from '../CustomPromise.js';

const resolvedPromise = new CustomPromise((resolve) => resolve('Hello, world!'));
resolvedPromise
  .then((value) => {
    console.log(value); // 'Hello, world!'
    throw new Error('Goodbye, world!');
  })
  .catch((err) => console.error(err));  // 'Error: Goodbye, world!'


const rejectedPromise = new CustomPromise((_, reject) => reject('Hello, world!'));
const result = await rejectedPromise
  .catch((rejectMessage) => rejectMessage.split(' '))
  .then(([firstWord]) => firstWord + ' Pepe!');
console.log(result); // Hello, Pepe!
```
### Подсказки
Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

Если почувствуете, что нужны дополнительные материалы:
* описание стандарта, который имплементируется в упражнении
* курс "Синхронная асинхронность", чуть глубже погружающий в тему
* курс "Автоматное программирование" о конечных автоматах, чем является промис
